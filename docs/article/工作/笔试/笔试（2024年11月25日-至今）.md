---
tag:
  - 笔试
---

# 笔试（2024年11月25日-至今）

## 1. mysql使用innodb引擎，请简述mysql索引的最左前缀如何优化orderby语句。

### 关键点

1. 如果排序字段不在索引列上，会导致文件排序。文件排序有两种算法： 双路排序和单路排序。
2. order by 不符合最左前缀会文件排序。
3. 方向反也会导致文件排序。

### 答案

1. 首先检查sql语句，检查查询字段、过滤字段、排序字段是否必要，顺序是否按照联合索引顺序。
2. 排序字段和索引顺序是否一致，否则会导致文件排序（filesort）。
3. 多个排序字段其升序降序不一致也会导致文件排序。
4. 多使用explain观察SQL语句执行效率。
5. 尽可能减少不必要得文件排序。

### 拓展

+ 针对 explain 各个属性的含义

| 属性            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| `id`            | 查询的标识符。如果查询包含子查询或联合查询，每个部分都有一个唯一的 `id`。 |
| `select_type`   | 查询的类型。<br>- `SIMPLE`：简单的查询，没有子查询或联合查询。<br>- `PRIMARY`：最外层的查询。<br>- `SUBQUERY`：子查询中的第一个 `SELECT`。<br>- `DERIVED`：派生表（来自 `FROM` 子句中的子查询）。<br>- `UNION`：联合查询的第二个或后续 `SELECT`。 |
| `table`         | 涉及的表名。如果表是派生表或子查询，可能会显示别名。         |
| `partitions`    | 涉及的分区（如果表是分区表）。                               |
| `type`          | 访问类型，表示如何访问表中的行。<br>- `ALL`：全表扫描。<br>- `index`：全索引扫描。<br>- `range`：索引范围扫描。<br>- `ref`：非唯一索引扫描。<br>- `eq_ref`：唯一索引扫描。<br>- `const`：常量扫描。<br>- `system`：系统表扫描。 |
| `possible_keys` | 可能使用的索引。                                             |
| `key`           | 实际使用的索引。                                             |
| `key_len`       | 使用的索引长度（字节数）。                                   |
| `ref`           | 引用的列或常量。                                             |
| `rows`          | 估计需要检查的行数。                                         |
| `filtered`      | 估计的过滤百分比（表示在索引或表扫描后，通过过滤条件保留的行的百分比）。 |
| `Extra`         | 额外的信息。<br>- `Using where`：使用了 `WHERE` 子句。<br>- `Using index`：覆盖索引，查询的所有列都在索引中。<br>- `Using temporary`：使用了临时表。<br>- `Using filesort`：使用了文件排序。<br>- `Using join buffer`：使用了连接缓冲区。<br>- `Impossible WHERE`：`WHERE` 子句总是为假。<br>- `Distinct`：使用了 `DISTINCT` 关键字。<br>- `Not exists`：使用了 `LEFT JOIN` 或 `RIGHT JOIN` 时，`ON` 条件为假。 |

+ 推荐使用索引的字段：①过滤字段②排序字段③分组字段④连接字段⑤覆盖索引字段⑥高选择性字段（值分布广泛、重复率低的字段）⑦经常用于查询的字段
+ 常见的索引：①普通索引②唯一索引③主键索引④联合索引⑤全文索引⑥空间索引⑦前缀索引⑧聚簇索引⑨非聚簇索引⑩哈希索引⑪位图索引（MySQL 不直接支持，但可以通过其他方式实现类似功能）
+ 针对是否创建索引考虑：①选择性（可使用 `SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;` 计算列的选择性）②查询频率③数据分布④索引维护成本⑤索引大小

## 2. JVM 内存模型中，为什么要区分新生代和年老代，对于新生代，为什么又要区分eden 区survial区?

### 关键点

1. 分清楚 JVM 标准与实现，主要针对 HotSpot 虚拟机
2. 分代收集算法，在 G1 上是逻辑划分，之前的垃圾回收器可以理解为物理上划分
3. 垃圾收集算法
4. **内存连续空间**

### 答案

1. Java 主流的垃圾回收器都使用了分代收集算法
2. 正常系统运行时会产生海量临时对象，这些对象短期内大部分就会失效，对于这些对象我们把他临时放到新生代
3. 新生代满了之后需要清理垃圾对象，我们会把有效对象复制到老年代，以便后续继续使用
4. 为了更有效的区分哪些对象应该被复制到老年代，所以在新生代划分出了 eden和 s0、s1 区域
5. 细化后的新生代内部被再次划分以便保证高速读写同时内存连续
   1. 新对象会被保存到 eden 区，起初 eden 区是空的所以内存连续，eden 区满了会把有效对象复制到 s0 ，同样 s0 起初是空的所以内存连续
   2. 清空 eden 区，保证下一次写入 eden 区内存也是连续的
   3. s0 和 s1 在命名上互换，保证下次写入 s0 内存也是连续的，它们之间使用了复制算法，保证以前老对象可以顺利存到新的区域
   4. eden 区再次满了，重复上述步骤
6. eden 区通过清除或复制算法，因为新生代的对象产生和销毁非常频繁，所以采用清空的方式

### 拓展

+ 运行时数据区域（针对 jdk 8）

线程共享：堆（字符串常量池）

线程私有：虚拟机栈、本地方法栈、程序计数器

本地内存：方法区（运行时常量池）、直接内存

+ 对象的创建

1. 类加载检查
2. 分配内存（分配方式：指针碰撞和空闲列表，具体使用哪个看堆是否规整，堆是否规整又看使用的垃圾回收器是否带有压缩整理的功能）
3. 初始化零值
4. 设置对象头
5. 执行 init 方法

+ 对象在内存中布局可以分为了三个区域：对象头（包括标记字段和类型指针两部分信息）、实例数据、对齐填充

+ 对象的访问定位主流方式：直接指针、使用句柄

+ 死亡对象判断方法：引用计数法、可达性分析算法

+ 垃圾收集算法：标记-清除算法、复制算法、标记整理算法、分代收集算法

## 3. A 系统远程调用 B 系统的接口，A 系统在完成调用之后，需要更新A 系统本地表。问题1:常见的远程调用有几种?问题 2: 对于有这些外部衔接的方法需要注意哪些问题?请写出注意问题及伪代码

### 关键点

1. 网络协议于封装，所有网路请求都是基于TCP或UDP协议
2. 常用框架：netty、grpc
3. 长短连接

### 问题1答案

1. 自定义协议实现（如自己写 socket、servlet）（实现复杂、需解决问题很多）
2. UDP广播类型（常见于即时通讯，速度快，可靠性低，若要可信，则要二次确认）
3. 基于http协议调用（Restful 风格的 api，Spring Cloud 微服务调用就基于 http，适用于追求通用性、异构性、延展性的系统）
4. dubbo 协议（阿里出品，长连接，专门针对Java语言，二进制封装数据，性能高）
5. soap 协议（古老的webservice系列框架，基于xml实现数据封装，http协议传输）
6. 异步响应式（WebFlux + Spring Data Reactice）
7. 服务器推（不主动调用，常见于系统通知）

### 问题2答案

1. 写好接口文档，方便后续维护和团队协作
2. 统一化的报文结构 
3. 标准化的服务状态码

4. 统一化请求日志记录,及异常记录
5. 当请求延迟过高，可以快速失败
6. 重试机制
7. 事务问题，可回滚
8. 数据一致性问题

## 4. springboot是如何管理版本依赖的？什么是自动配置、起步依赖?

### 关键点

+ Maven
+ spring boot pom.xml 父子依赖
+ spring-boot-starter

### 问题1答案

spring boot 底层使用 Maven 管理依赖，通过控制 pom.xml 父子关系来完成细节配置，在父 pom 中具体定义使用框架和版本号以及额外信息。

### 问题2答案

1. 以前由于使用各种库，还需要针对这些库进行具体配置。spring boot 对这些常见框架都提供了默认配置。
2. 只要在 spring boot 的启动类上使用 @SpringApplication 就可实现自动配置
3. 底层实现，@SpringApplication 又使用 @AutoConfigurationPackage 自动读取每个 jar 包的 META-INF/Spring.factories和 spring-boot-autoconfigure 的默认配置

### 问题3答案

spring boot 为不同环境提供了不同的 starter，不再需要我们针对不同环境进行不同配置。

## 5. 数据库索引的原理?创建索引的缺点是什么，什么情况索引失效?优化数据库的方法有哪些?

### 关键点

+ 哪种数据库（关系型数据库都差不多）
+ 以 MySQL 的索引为例
+ 索引的好处和代价
+ 索引失效的情况
+ 优化（硬件、软件层面）

### 问题1答案

1. MySQL 的 InnoDB 存储引擎使用了 b+ 树实现索引，在索引查找上实现了 log n 的时间复杂度
2. b+ 树的叶子节点以链表形式存储，方便了顺序扫描、范围查找和排序
3. 在 InnoDB 中默认主键索引作为聚簇索引
4. 在聚簇索引的叶子节点存储了完整的行数据，非聚簇索引的叶子节点记录主键和索引字段

### 问题2答案

1. 会占用一定空间
2. 会影响插入、更新、删除操作的性能
3. 可能影响缓存命中，由于链表指针影响导致相邻叶子节点可能并不是连续存储
4. 影响并行处理的效率

### 问题3答案

1. 计算、排序
2. 使用 LIKE 以 % 开头
3. 不等于（!= 或者 <>）
4. 使用 OR 条件
5. IS NOT NULL 可能会失效（由不同的版本和数据决定）、IS NULL 有效
6. 隐式类型转换
7. 数据库优化器觉得不使用索引会更快