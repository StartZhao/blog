---
tag:
  - 笔试
---

# 笔试（2024年11月25日-至今）

## 1. mysql使用innodb引擎，请简述mysql索引的最左前缀如何优化orderby语句。

### 关键点

1. 如果排序字段不在索引列上，会导致文件排序。文件排序有两种算法： 双路排序和单路排序。
2. order by 不符合最左前缀会文件排序。
3. 方向反也会导致文件排序。

### 答案

1. 首先检查sql语句，检查查询字段、过滤字段、排序字段是否必要，顺序是否按照联合索引顺序。
2. 排序字段和索引顺序是否一致，否则会导致文件排序（filesort）。
3. 多个排序字段其升序降序不一致也会导致文件排序。
4. 多使用explain观察SQL语句执行效率。
5. 尽可能减少不必要得文件排序。

### 拓展

+ 针对 explain 各个属性的含义

| 属性            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| `id`            | 查询的标识符。如果查询包含子查询或联合查询，每个部分都有一个唯一的 `id`。 |
| `select_type`   | 查询的类型。<br>- `SIMPLE`：简单的查询，没有子查询或联合查询。<br>- `PRIMARY`：最外层的查询。<br>- `SUBQUERY`：子查询中的第一个 `SELECT`。<br>- `DERIVED`：派生表（来自 `FROM` 子句中的子查询）。<br>- `UNION`：联合查询的第二个或后续 `SELECT`。 |
| `table`         | 涉及的表名。如果表是派生表或子查询，可能会显示别名。         |
| `partitions`    | 涉及的分区（如果表是分区表）。                               |
| `type`          | 访问类型，表示如何访问表中的行。<br>- `ALL`：全表扫描。<br>- `index`：全索引扫描。<br>- `range`：索引范围扫描。<br>- `ref`：非唯一索引扫描。<br>- `eq_ref`：唯一索引扫描。<br>- `const`：常量扫描。<br>- `system`：系统表扫描。 |
| `possible_keys` | 可能使用的索引。                                             |
| `key`           | 实际使用的索引。                                             |
| `key_len`       | 使用的索引长度（字节数）。                                   |
| `ref`           | 引用的列或常量。                                             |
| `rows`          | 估计需要检查的行数。                                         |
| `filtered`      | 估计的过滤百分比（表示在索引或表扫描后，通过过滤条件保留的行的百分比）。 |
| `Extra`         | 额外的信息。<br>- `Using where`：使用了 `WHERE` 子句。<br>- `Using index`：覆盖索引，查询的所有列都在索引中。<br>- `Using temporary`：使用了临时表。<br>- `Using filesort`：使用了文件排序。<br>- `Using join buffer`：使用了连接缓冲区。<br>- `Impossible WHERE`：`WHERE` 子句总是为假。<br>- `Distinct`：使用了 `DISTINCT` 关键字。<br>- `Not exists`：使用了 `LEFT JOIN` 或 `RIGHT JOIN` 时，`ON` 条件为假。 |

+ 推荐使用索引的字段：①过滤字段②排序字段③分组字段④连接字段⑤覆盖索引字段⑥高选择性字段（值分布广泛、重复率低的字段）⑦经常用于查询的字段
+ 常见的索引：①普通索引②唯一索引③主键索引④联合索引⑤全文索引⑥空间索引⑦前缀索引⑧聚簇索引⑨非聚簇索引⑩哈希索引⑪位图索引（MySQL 不直接支持，但可以通过其他方式实现类似功能）
+ 针对是否创建索引考虑：①选择性（可使用 `SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;` 计算列的选择性）②查询频率③数据分布④索引维护成本⑤索引大小

## 2. JVM 内存模型中，为什么要区分新生代和年老代，对于新生代，为什么又要区分eden 区survial区?

### 关键点

1. 分清楚 JVM 标准与实现，主要针对 HotSpot 虚拟机
2. 分代收集算法，在 G1 上是逻辑划分，之前的垃圾回收器可以理解为物理上划分
3. 垃圾收集算法
4. **内存连续空间**

### 答案

1. Java 主流的垃圾回收器都使用了分代收集算法
2. 正常系统运行时会产生海量临时对象，这些对象短期内大部分就会失效，对于这些对象我们把他临时放到新生代
3. 新生代满了之后需要清理垃圾对象，我们会把有效对象复制到老年代，以便后续继续使用
4. 为了更有效的区分哪些对象应该被复制到老年代，所以在新生代划分出了 eden和 s0、s1 区域
5. 细化后的新生代内部被再次划分以便保证高速读写同时内存连续
   1. 新对象会被保存到 eden 区，起初 eden 区是空的所以内存连续，eden 区满了会把有效对象复制到 s0 ，同样 s0 起初是空的所以内存连续
   2. 清空 eden 区，保证下一次写入 eden 区内存也是连续的
   3. s0 和 s1 在命名上互换，保证下次写入 s0 内存也是连续的，它们之间使用了复制算法，保证以前老对象可以顺利存到新的区域
   4. eden 区再次满了，重复上述步骤
6. eden 区通过清除或复制算法，因为新生代的对象产生和销毁非常频繁，所以采用清空的方式

### 拓展

+ 运行时数据区域（针对 jdk 8）

线程共享：堆（字符串常量池）

线程私有：虚拟机栈、本地方法栈、程序计数器

本地内存：方法区（运行时常量池）、直接内存

+ 对象的创建

1. 类加载检查
2. 分配内存（分配方式：指针碰撞和空闲列表，具体使用哪个看堆是否规整，堆是否规整又看使用的垃圾回收器是否带有压缩整理的功能）
3. 初始化零值
4. 设置对象头
5. 执行 init 方法

+ 对象在内存中布局可以分为了三个区域：对象头（包括标记字段和类型指针两部分信息）、实例数据、对齐填充

+ 对象的访问定位主流方式：直接指针、使用句柄

+ 死亡对象判断方法：引用计数法、可达性分析算法

+ 垃圾收集算法：标记-清除算法、复制算法、标记整理算法、分代收集算法