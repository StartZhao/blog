---
tag:
  - 笔试
---

# 笔试（2024年10月15日）

## 1. 请简述Vue.js的生命周期函数及其执行顺序。

Vue.js 是一个用于构建用户界面的渐进式框架。Vue 实例从创建到销毁的过程中会经历一系列的阶段，这些阶段被称为生命周期。在每个阶段，Vue 都提供了对应的生命周期钩子（生命周期函数），允许开发者在特定的时间点执行自定义操作。

以下是 Vue.js 生命周期的主要钩子及其执行顺序：

1. beforeCreate：实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。此时，组件的属性还未挂载，数据模型还未绑定。
2. created：实例创建完成后立即调用，此时已完成以下操作：初始化事件、属性等，但是挂载阶段还没开始，`$el` 属性还不可用。
3. beforeMount：在挂载开始之前被调用：相关的 `render` 函数首次被调用。此时模板编译/渲染前，虚拟 DOM 尚未生成，真实 DOM 还没有被修改。
4. mounted：当 Vue 实例挂载完成后被调用，此时 `el` 被新创建的 `vm.$el` 替换，并且插入到了 DOM 中。此时可以访问真实的 DOM 元素，通常用来发送网络请求获取数据。
5. beforeUpdate：当数据更改导致虚拟 DOM 重新渲染和打补丁之前调用。此时你可以访问更新前的状态值，这是做任何需要与DOM进行交互的操作的好时机。
6. updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。
7. beforeDestroy（Vue 2.x） / beforeUnmount（Vue 3.x）：实例销毁之前调用。在这一步，实例仍然是完全可用的，可以进行最后的数据清理工作，如取消定时器或取消网络请求。
8. destroyed（Vue 2.x） / unmounted（Vue 3.x）：Vue 实例销毁后调用。调用此钩子时，Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有子实例也都被销毁。
9. activated：`keep-alive` 组件激活时调用。只有使用了 `<keep-alive>` 包裹的组件才会触发这个钩子。
10. deactivated：`keep-alive` 组件停用时调用。同样，只有使用了 `<keep-alive>` 包裹的组件才会触发这个钩子。

## 2. Vue.js中的v-bind指令和v-model指令有什么区别？

**v-bind 指令**

`v-bind` 指令用于动态地绑定一个或多个属性，或一个组件 prop 到表达式。它可以根据 Vue 实例的数据动态地设置 HTML 元素的属性值。

**v-model 指令**

`v-model` 指令提供了一个方便的方式实现双向数据绑定。它主要用于表单输入控件（如 `<input>`, `<textarea>`, `<select>` 等）和 Vue 实例之间的数据同步。

**主要区别**

1. **用途不同**：
   - `v-bind` 用于单向绑定，即从 Vue 实例的数据流向 DOM 属性。
   - `v-model` 用于双向绑定，即不仅从 Vue 实例的数据流向 DOM 输入控件，也从 DOM 输入控件回流到 Vue 实例的数据。
2. **适用范围不同**：
   - `v-bind` 可以用于任何 HTML 属性或组件 prop。
   - `v-model` 主要用于表单输入控件，实现数据的双向绑定。
3. **内部机制不同**：
   - `v-bind` 内部通过 `setAttribute` 方法来设置属性值。
   - `v-model` 内部通过监听输入事件（如 `input` 或 `change`）来更新 Vue 实例的数据。

**总结**

- 使用 `v-bind` 时，Vue 实例的数据变化会自动更新 DOM 属性。
- 使用 `v-model` 时，DOM 输入控件的变化会自动更新 Vue 实例的数据，同时 Vue 实例的数据变化也会更新 DOM 输入控件。

## 3. 请简述Vue.js的组件通信方式及其优缺点。

在 Vue.js 中，组件通信是一个非常重要的概念，因为组件化开发模式使得应用结构更加清晰和可维护。Vue 提供了多种组件通信的方式，每种方式都有其适用场景和优缺点。以下是几种常见的组件通信方式及其特点：

### 1. Props 和 Events（父传子，子传父）

**Props（父组件向子组件传递数据）**

- **描述**：父组件通过在子组件标签上使用属性的方式来传递数据。
- **优点**：
  - 简单易用，适合简单的父子组件通信。
  - 数据流动方向明确，易于理解和调试。
- **缺点**：
  - 对于多层嵌套的组件，传递数据需要逐层传递，可能会导致代码冗余。
  - 不适用于非父子关系的组件通信。

**Events（子组件向父组件传递消息）**

- **描述**：子组件通过 `$emit` 触发事件，父组件通过 `v-on` 监听这些事件来接收数据。
- **优点**：
  - 简单易用，适合简单的父子组件通信。
  - 数据流动方向明确，易于理解和调试。
- **缺点**：
  - 对于多层嵌套的组件，传递事件需要逐层传递，可能会导致代码冗余。
  - 不适用于非父子关系的组件通信。

### 2. Provide 和 Inject（祖先组件向后代组件传递数据）

- **描述**：祖先组件通过 `provide` 提供数据，后代组件通过 `inject` 注入数据。
- **优点**：
  - 解决了多层嵌套组件间的数据传递问题。
  - 数据传递不依赖于中间组件，减少了代码冗余。
- **缺点**：
  - 数据流动方向不明确，可能增加代码的复杂性。
  - 不适合大量数据传递，容易造成性能问题。

### 3. Vuex（状态管理库）

- **描述**：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
- **优点**：
  - 集中管理状态，适合大型复杂应用。
  - 提供了丰富的工具和插件支持，如时间旅行调试等。
  - 数据流动方向明确，便于调试和维护。
- **缺点**：
  - 学习曲线较高，不适合小型简单应用。
  - 增加了项目的复杂性和代码量。

### 4. Event Bus（事件总线）

- **描述**：通过创建一个全局的事件中心（通常是一个空的 Vue 实例），组件之间可以通过这个事件中心进行通信。
- **优点**：
  - 解决了非父子关系组件间的通信问题。
  - 实现简单，易于理解。
- **缺点**：
  - 事件管理较为松散，容易出现内存泄漏。
  - 不适合大规模复杂应用，容易导致代码难以维护。

### 5. Refs（直接访问子组件实例）

- **描述**：通过 `ref` 属性为子组件分配一个引用 ID，然后在父组件中通过这个引用 ID 访问子组件的实例。
- **优点**：
  - 直接访问子组件的方法和属性，适合特定场景下的直接操作。
- **缺点**：
  - 违反了单向数据流的原则，可能导致代码难以理解和维护。
  - 不适合复杂的组件通信需求。

### 总结

选择合适的组件通信方式取决于具体的应用场景和项目需求。对于简单的父子组件通信，使用 `props` 和 `events` 就足够了；对于多层嵌套组件的数据传递，可以考虑使用 `provide` 和 `inject`；对于大型复杂应用，推荐使用 Vuex 进行状态管理；而对于非父子关系组件的通信，可以使用事件总线或 `refs`。每种方式都有其适用场景，合理选择可以提高开发效率和代码质量。

## 4. 请简述Vue.js中的响应式原理。

Vue.js 的响应式系统是其核心特性之一，它使得数据的变化能够自动反映到视图上，而无需手动操作 DOM。

Vue.js 的响应式原理主要基于以下几个关键技术：

1. **数据劫持**：通过 `Object.defineProperty`（Vue 2.x）或 `Proxy`（Vue 3.x）劫持数据对象的属性，使其变得响应式。当这些属性被访问或修改时，Vue 可以捕获到这些操作，并作出相应的反应。
2. **依赖收集**：在属性被访问时，Vue 记录下哪些组件依赖于这个属性。
3. **视图更新**：当数据发生变化时，Vue 通知所有依赖于这个数据的组件重新计算并更新视图。

## 5. 如何在Vue.js中实现路由跳转？

在 Vue.js 中，实现路由跳转通常使用 Vue Router，这是一个官方支持的路由管理库。Vue Router 可以帮助你管理应用中的不同页面和导航逻辑。

下面是如何在 Vue.js 中实现路由跳转的步骤和示例代码。

1. 安装 Vue Router：使用 npm 安装 Vue Router。
2. 创建路由配置：定义路由规则和对应的组件。
3. 在主文件中引入路由 ：在 `main.js` 中引入并使用路由配置。
4. 在组件使用路由：使用 `<router-link>` 组件或编程式导航进行路由跳转。
5. 在方法中使用路由：使用 `this.$router.push` 或 `this.$router.replace`
6. 使用 `<router-view>` 渲染组件：在模板中使用 `<router-view>` 显示匹配到的组件。
7. 监听路由变化：使用 `beforeEach` 或 `afterEach` 钩子。

## 6. Vue.js 中的 computed和watch有什么区别？

在 Vue.js 中，`computed` 和 `watch` 都是用来处理数据变化的，但它们的使用场景和工作机制有所不同。下面详细解释两者的区别：

### 1. Computed（计算属性）

**定义**

`computed` 是一种特殊的属性，它的值是基于其他数据属性计算出来的。计算属性是基于它们的依赖进行缓存的，只有当依赖的数据发生变化时，计算属性才会重新求值。

**用途**

用于基于其他数据属性计算出新的属性值。

**主要特点**

- **缓存机制**：计算属性是基于它们的依赖进行缓存的，只有当依赖的数据发生变化时，计算属性才会重新求值。这意味着只要依赖的数据没有变化，多次访问计算属性会立即返回之前的计算结果，而不需要再次执行计算函数。
- **自动依赖追踪**：计算属性会自动追踪其依赖的数据，并在依赖数据变化时重新计算。
- **简洁易用**：计算属性的使用非常直观，适合处理简单的数据计算和转换。

**使用场景**

需要根据其他数据属性动态计算某个值时，使用 `computed`。

### 2. Watch（侦听器）

**定义**

`watch` 用于观察和响应 Vue 实例上的数据变化。当被观察的数据发生变化时，回调函数会被触发，并可以执行一些自定义的操作。

**用途**

用于观察和响应数据变化，执行自定义操作。

**主要特点**

- **异步或开销较大的操作**：当需要在数据变化时执行异步操作或开销较大的操作时，使用 `watch` 更合适。
- **细粒度控制**：`watch` 提供了更多的控制能力，可以访问到旧值和新值，以及在回调函数中执行更复杂的逻辑。
- **手动触发**：`watch` 不会自动缓存结果，每次数据变化都会触发回调函数。

**使用场景**

需要在数据变化时执行复杂的逻辑或异步操作时，使用 `watch`。

## 7. Vue.js中的v-for指令和v-if指令有什么区别？

### 1. v-for 指令

**定义**

`v-for` 指令用于基于一个数组或对象来重复渲染元素或组件。它是 Vue 中最强大的指令之一，适用于列表渲染。

**主要特点**

- **列表渲染**：用于遍历数组或对象，生成多个相同的元素或组件。
- **性能优化**：Vue 会尽可能地重用和更新 DOM 元素，而不是每次都重新创建，从而提高性能。
- **键值对**：可以访问数组的索引或对象的键值对。

### 2. v-if 指令

**定义**

`v-if` 指令用于条件性地渲染元素或组件。如果条件为 `false`，元素将不会被渲染到 DOM 中。

**主要特点**

- **条件渲染**：用于根据条件决定是否渲染某个元素或组件。
- **切换行为**：当条件从 `true` 变为 `false` 时，元素会被销毁；当条件从 `false` 变为 `true` 时，元素会被重新创建。
- **性能考虑**：频繁的条件切换会导致不必要的 DOM 操作，影响性能。

### 区别总结

1. **用途不同**：
   - **v-for**：用于基于数组或对象生成多个相同的元素或组件，适用于列表渲染。
   - **v-if**：用于根据条件决定是否渲染某个元素或组件，适用于条件渲染。
2. **渲染机制不同**：
   - **v-for**：会遍历数组或对象，生成多个 DOM 元素。Vue 会尽可能地重用和更新现有的 DOM 元素，而不是每次都重新创建。
   - **v-if**：根据条件决定是否渲染元素。如果条件为 `false`，元素将不会被渲染到 DOM 中；如果条件从 `false` 变为 `true`，元素会被重新创建。
3. **性能考虑**：
   - **v-for**：适用于静态或不经常变化的数据列表，因为 Vue 会优化 DOM 更新。
   - **v-if**：适用于频繁切换的情况，但需要注意频繁的条件切换会导致不必要的 DOM 操作，影响性能。

### v-for 和 v-if 的结合使用

虽然 `v-for` 和 `v-if` 可以一起使用，但 Vue 官方建议避免这样做，因为这会导致不必要的渲染和性能问题。如果需要根据条件过滤列表，可以使用计算属性来处理数据，然后再使用 `v-for` 渲染。

## 8. 请简述Vue.js中的mixins和extends的作用及其区别。

在Vue.js中，`mixins` 和 `extends` 是两种用于代码复用的机制，它们可以帮助开发者减少重复代码，并且使得组件的功能更加模块化。下面是两者的简要介绍以及它们之间的主要区别：

### Mixins

**作用**：

- `mixins` 是一种向组件注入可复用功能的方式。它允许你在多个组件之间复用行为（如方法、计算属性等）。
- 当一个组件使用了某个 `mixin`，这个组件就会继承 `mixin` 中定义的所有选项，包括数据属性、方法、生命周期钩子等。
- `mixins` 可以包含任何组件选项，例如 `data`、`methods`、`components`、`directives` 等。

**特点**：

- `mixins` 的选项会与组件本身的选项合并。如果两者中有相同的选项（比如同一个方法名），那么组件内的选项会覆盖 `mixin` 中的选项。
- 如果多个 `mixins` 提供了同名选项，则只有最后一个 `mixin` 中的值会被使用。
- 在生命周期钩子的情况下，混合到组件中的所有钩子将会按照特定顺序调用（先调用组件自身的钩子，然后是每个 `mixin` 的钩子，按它们混合进来的顺序）。

### Extends

**作用**：

- `extends` 关键字用于扩展一个已存在的 Vue 组件。这使得新的组件可以继承原有组件的所有属性，同时还可以添加或覆盖原有的属性。
- 使用 `extends` 可以创建基于另一个组件的新组件，这对于创建具有相似功能但又有所不同的组件非常有用。

**特点**：

- 新组件将完全继承原有组件的所有特性，包括数据、方法、计算属性等。
- 新组件可以覆盖原有组件的方法或添加新的方法。
- 生命周期钩子的行为类似于 `mixins`，即新组件的钩子会在原有组件的钩子之后执行。

### 区别

- **用途不同**：`mixins` 主要用于跨多个组件间共享功能，而 `extends` 则更适用于创建基于现有组件的新组件。
- **合并策略**：虽然两者都会发生选项合并的情况，但是 `mixins` 更多的是为了增加功能，而 `extends` 则是为了修改或增强现有的组件。
- **作用范围**：Mixins 可以被多个组件同时使用，而 `extends` 创建的新组件只能一对一地继承一个组件。

总的来说，选择使用 `mixins` 还是 `extends` 应该根据具体的应用场景来决定。如果需要在一个应用中多次复用某些功能，`mixins` 是更好的选择；如果希望创建一个基于现有组件的新组件，`extends` 则更为合适。

## 9. Vue.js中的keep-alive组件有什么作用？如何使用？

`<keep-alive>` 是 Vue.js 提供的一个内置组件，用于缓存动态组件，从而提高应用性能。它的主要作用是在组件切换时保留组件的状态，避免重新渲染组件，这样可以显著提升用户体验，尤其是在频繁切换组件的应用中。

### `<keep-alive>` 的作用

1. **状态保持**：当包裹的组件在 `<keep-alive>` 内部被切换时，其内部的状态不会丢失，即使组件被销毁后再次激活，状态也会被恢复。
2. **减少渲染开销**：对于一些初始化成本较高或者数据加载较慢的组件，使用 `<keep-alive>` 可以避免每次切换时都重新渲染，从而节省资源。
3. **生命周期控制**：被 `<keep-alive>` 包裹的组件会接收到两个额外的生命周期钩子：`activated` 和 `deactivated`。这些钩子分别在组件被激活（显示）和停用（隐藏）时调用，可以用来执行一些清理工作或重新获取数据等操作。

### 如何使用 `<keep-alive>`

基本用法如下：

```html
<template>
  <div>
    <keep-alive>
      <component :is="currentComponent"></component>
    </keep-alive>
  </div>
</template>

<script>
export default {
  data() {
    return {
      currentComponent: 'ComponentA' // 默认显示 ComponentA
    };
  },
  methods: {
    switchComponent(componentName) {
      this.currentComponent = componentName;
    }
  }
}
</script>
```

在这个例子中，`<keep-alive>` 包裹了一个动态组件 `<component:is="currentComponent">`。`currentComponent` 的值决定了哪个组件会被渲染。当 `currentComponent` 的值发生变化时，新的组件将被激活，而之前被激活的组件则会被停用，但其状态会被保存。

### 配置选项

`<keep-alive>` 组件还支持一些配置选项来进一步控制缓存行为：

- **include**：字符串或正则表达式。只有名称匹配的组件会被缓存。
- **exclude**：字符串或正则表达式。任何名称匹配的组件都不会被缓存。
- **max**：数字，设置最多可以缓存多少个组件实例。

例如，只缓存名为 `ComponentA` 的组件，可以这样做：

```html
<keep-alive include="ComponentA">
  <component :is="currentComponent"></component>
</keep-alive>
```

或者限制最多缓存三个组件实例：

```html
<keep-alive :max="3">
  <component :is="currentComponent"></component>
</keep-alive>
```

## 10. MyBatis的缓存机制

MyBatis 的缓存机制主要包括一级缓存（Session 缓存）和二级缓存（Mapper 缓存）。这两种缓存机制旨在减少对数据库的直接访问次数，从而提高应用程序的性能。

### 一级缓存（Session 缓存）

**工作原理**

- **作用域**：一级缓存的作用域是单个 `SqlSession` 实例。
- **生命周期**：当 `SqlSession` 被关闭或提交事务后，一级缓存会被清空。
- **自动管理**：MyBatis 自动管理一级缓存，无需手动配置。
- **默认启用**：一级缓存默认是开启的。

**使用场景**

- 在同一个 `SqlSession` 内进行多次查询相同的数据时，可以利用一级缓存减少数据库访问次数。
- 对于短生命周期的操作，如一次请求处理中多次查询相同的数据，一级缓存效果明显。

### 二级缓存（Mapper 缓存）

**工作原理**

- **作用域**：二级缓存的作用域是同一个命名空间（Mapper 文件）内的所有 `SqlSession`。
- **生命周期**：二级缓存的数据会一直存在，直到显式清除或达到缓存策略的最大值。
- **手动配置**：需要在 MyBatis 配置文件中手动开启，并在对应的 Mapper 文件中启用。
- **缓存插件**：可以使用第三方缓存插件（如 Ehcache、Redis 等）来实现更复杂的缓存策略。

**开启方式**

1. **全局配置**：在 MyBatis 的全局配置文件中开启二级缓存。

   ```xml
   <settings>
     <setting name="cacheEnabled" value="true"/>
   </settings>
   ```

2. **Mapper 文件配置**：在需要使用二级缓存的 Mapper 文件中添加 `<cache>` 标签。

   ```xml
   <mapper namespace="com.example.mapper.UserMapper">
     <cache/>
     <!-- 或者配置更详细的缓存策略 -->
     <cache eviction="LRU" flushInterval="60000" size="512" readOnly="true"/>
     <!-- 映射语句 -->
   </mapper>
   ```

**参数说明**

- **eviction**：缓存回收策略，可选值有 LRU（最近最少使用）、FIFO（先进先出）、SOFT（软引用）、WEAK（弱引用）。
- **flushInterval**：缓存刷新间隔时间（毫秒），超过此时间未使用的缓存项将被清除。
- **size**：缓存最大条目数。
- **readOnly**：是否只读，默认为 `false`。如果设置为 `true`，则所有从缓存中获取的数据都将被视为只读，这可以提高性能但会影响数据的一致性。

**使用场景**

- 对于不经常变化的数据，如字典表、静态配置等，适合使用二级缓存来减少数据库访问。
- 在多用户并发访问的场景下，二级缓存可以显著提高系统的响应速度和吞吐量。

### 注意事项

- **数据一致性**：使用缓存时需要注意数据的一致性问题。特别是当数据在外部被修改时，缓存中的数据可能已经过期。
- **缓存穿透**：对于不存在的数据，多次查询可能会导致缓存穿透。可以通过缓存空结果的方式来防止这种情况。
- **缓存雪崩**：当大量缓存数据在同一时间失效时，可能会导致短时间内大量的数据库请求，造成系统压力。可以通过设置合理的缓存过期时间和过期策略来缓解这个问题。

### 总结

通过合理配置和使用 MyBatis 的一级和二级缓存，可以有效提升应用程序的性能和用户体验。一级缓存适用于短生命周期的操作，而二级缓存适用于多用户并发访问的场景。正确理解和使用这些缓存机制，能够帮助开发者构建高性能的数据库访问层。

## 11. MyBatis中ResultMap与ResultType区别用法

在 MyBatis 中，`resultType` 和 `resultMap` 都是用来指定查询结果如何映射到 Java 对象的属性，但它们的使用方式和灵活性有所不同。

### resultType

**定义**

`resultType` 是一个简单的属性，用于指定查询结果应该映射到的 Java 类型。它通常用于简单的查询结果映射，即查询结果可以直接映射到一个简单的 Java 对象或基本类型。

**使用场景**

- 查询结果结构简单，可以直接映射到一个 Java 对象或基本类型。
- 不需要复杂的映射关系，如嵌套对象、集合等。

### resultMap

**定义**

`resultMap` 是一个更复杂的映射配置，用于定义查询结果与 Java 对象之间的映射关系。它可以处理复杂的映射需求，如嵌套对象、集合、自定义列名映射等。

**使用场景**

- 查询结果结构复杂，需要映射到嵌套对象或集合。
- 需要自定义列名映射到 Java 对象的属性。
- 需要处理多表关联查询的结果。

### 主要区别

1. **简单 vs 复杂**
   - `resultType` 适用于简单的映射需求，查询结果可以直接映射到一个简单的 Java 对象或基本类型。
   - `resultMap` 适用于复杂的映射需求，可以处理嵌套对象、集合、自定义列名映射等。
2. **配置复杂度**
   - `resultType` 配置简单，只需指定结果类型。
   - `resultMap` 配置复杂，需要定义详细的映射关系。
3. **灵活性**
   - `resultType` 灵活性较低，只能处理简单的映射。
   - `resultMap` 灵活性高，可以处理复杂的映射需求。

### 总结

- **resultType**：适用于简单的查询结果映射，配置简单，但灵活性较低。
- **resultMap**：适用于复杂的查询结果映射，配置复杂，但灵活性高，可以处理嵌套对象、集合、自定义列名映射等。

## 12. Mybatis中`#{}`与`${}`区别

在MyBatis框架中，`#{}` 和 `${}` 都是用来传递参数的，但是它们之间有显著的区别，主要体现在SQL注入安全性和处理方式上。

### `#{}`

- **预编译处理**：当你使用 `#{}` 标记来传递参数时，MyBatis会将这些标记视为预处理语句（PreparedStatement）中的参数。这意味着，实际的值会在执行SQL之前被替换，并且会被数据库驱动以安全的方式处理，这样可以有效防止SQL注入攻击。
- **类型安全**：由于 `#{}` 使用的是预编译参数，所以它可以正确地处理Java中的各种数据类型，包括日期、数字等，而不仅仅是字符串。
- **动态设置**：`#{}` 支持动态设置参数值，比如从对象的属性获取值。

### `${}`

- **直接替换**：`${}` 是一个简单的字符串替换机制，它会直接将变量的值插入到SQL语句中。这种方式不会对插入的数据进行任何转义或检查，因此如果直接使用用户输入的数据而不加处理，就可能遭受SQL注入攻击。
- **灵活性**：虽然 `${}` 存在SQL注入的风险，但在某些情况下它的灵活性是必要的，例如动态表名或列名的选择，因为这些不能通过预编译参数来实现。

### 安全建议

- 尽量使用 `#{}` 来避免SQL注入的风险。
- 如果必须使用 `${}`，确保所有传入的数据都经过了严格的验证和清理，以防止潜在的安全问题。

## 参考文献

+ [Vue.js 官方文档](https://vuejs.org/v2/guide/)
+ [MyBatis 官方文档](http://mybatis.github.io/mybatis-3/)

