---
tag:
  - 笔试
---

# 笔试（2024年10月11日-至今）

## 1. 用 Java 实现栈

栈的示意图

![](https://raw.githubusercontent.com/StartZhao/blog-images/refs/heads/main/%E7%AC%94%E8%AF%95/2024-10-12_10-13-58.png)

栈中的操作方法

+ `push(element)`：将元素压入栈顶。
+ `pop()`：弹出并返回栈顶的元素。
+ `top()`：返回栈顶元素，但不删除。
+ `isEmpty()`：判断栈是否为空。
+ `size()`：返回栈中元素的个数。

实现这些操作方法，**需要考虑边界情况**，如栈为空是执行 `pop()` 或 `top()` 操作的处理。

简单实现

1. 定义一个 Stack 类。
2. 在 Stack 类中声明私有变量，用于存储栈的元素。用数组或者链表实现。
3. 实现构造方法，初始化栈的大小和其他必要的变量。
4. 实现上述栈的操作方法。

```java
public class Stack {
    private int[] arr;
    private int top;

    public Stack(int capacity) {
        arr = new int[capacity];
        top = -1;
    }

    // 压入栈
    public void push(int element) {
        if (top == arr.length - 1) {
            throw new IllegalStateException("栈已满！");
        }
        top++;
        arr[top] = element;
    }

    // 弹出栈
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("栈为空！");
        }
        return arr[top--];
    }

    // 获取栈顶元素
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("栈为空！");
        }
        return arr[top];
    }

    // 栈是否为空
    public boolean isEmpty() {
        return top == -1;
    }

    // 栈是否已满
    public boolean isFull() {
        return top == arr.length - 1;
    }

    // 获取栈中元素个数
    public int size() {
        return top + 1;
    }
}
```

使用数组 `arr` 存储栈的元素，使用 `top` 记录栈顶的索引。

可以的话，先讨论栈的基本操作和边界情况，再进行代码编写。

## 2. 加权轮询算法的实现

加权轮询算法是一种常用的负载均衡算法，广泛应用于分布式系统中。它通过给不同的服务器分配不同的权重来实现请求的均衡分发。

算法运行过程

1. 算法开始时，为每个服务器分配一个**初始权重**，通常情况下，权重值可以根据服务器的性能、处理能力、连接数等因素进行设置。权重值越高，表示该服务器可以处理更多的请求。
2. 当新的请求到达时，负载均衡器会选择具有最高权重的服务器处理该请求。
3. 选定服务器处理请求后，该服务器的权重会减去一个事先设定好的值，以降低其权重，使得在下一次轮询中被选中的可能性减小。
4. 当所有服务器的权重值都减为 0 时，他们将重新被赋予初始权重值，然后再次参与请求的分发。
5. 重复上述步骤，直到服务终止或者负载均衡器收到终止信号。

加权轮询算法的优点：简单且易于理解，它能够根据服务器的处理能力自动调整请求的分发比例。较为强大的服务器可以拥有更高的权重，从而更频繁地接收到请求，以提高整个系统的吞吐量。此外，该算法不需要记录每个会话的状态信息，因此具有较低的空间复杂度。

然而，加权轮询算法也存在一些缺点：首先，它并不能考虑服务器的实际负载情况，只是根据预设的权重进行分发，无法根据服务器的实时负载状态进行动态调整。另外，如果权重的设置不合理，可能导致某些服务器负载过重，而其他服务器服务器处于闲置状态。

简单概括：使用加权轮询（Weighted Round Robin）算法时，服务器根据每个服务器的权重值来决定请求应该发送给哪个服务器。权重越高的服务器将获得更多的请求。

加权轮询核心类 `WeightedRoundRobin`

```java
public class WeightedRoundRobin {
    private final List<Server> servers;
    private int currentIndex;
    private int maxWeight;
    private int getWeight;

    public WeightedRoundRobin(List<Server> servers) {
        this.servers = new ArrayList<>(servers);
        currentIndex = -1;
        if (!servers.isEmpty()) {
            this.maxWeight = findMaxWeight();
            this.getWeight = calculateGcd();
        }
    }

    /**
     * 按照加权轮询逻辑检索下一个服务器
     * @return
     */
    public Server getNextServer() {
        if (servers.isEmpty()) {
            return null;
        }

        while (true) {
            currentIndex = (currentIndex + 1) % servers.size();
            if (currentIndex == 0) {
                maxWeight -= getWeight;
                if (maxWeight <= 0) {
                    maxWeight = findMaxWeight();
                    if (maxWeight == 0) {
                        // 如果所有服务器的权重都为 0，无法分配请求
                        return null;
                    }
                }
            }
            if (servers.get(currentIndex).getWeight() >= maxWeight) {
                return servers.get(currentIndex);
            }
        }
    }

    /**
     * 获取所有服务器中的最大权重
     *
     * @return
     */
    private int findMaxWeight() {
        return servers.stream().mapToInt(Server::getWeight).max().orElse(0);
    }

    /**
     * 计算所有服务器权重的最大公约数
     *
     * @return
     */
    private int calculateGcd() {
        return servers.stream().mapToInt(Server::getWeight).reduce(this::gcd).orElse(0);
    }

    /**
     * 计算两个数的最大公约数
     *
     * @param a
     * @param b
     * @return
     */
    private int gcd(int a, int b) {
        while (b != 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }
        return a;
    }
}
```

服务器 `Server`

```java
public class Server {
    private String name;
    private int weight;

    public Server(String name, int weight) {
        this.name = name;
        this.weight = weight;
    }

    public String getName() {
        return name;
    }

    public int getWeight() {
        return weight;
    }
}
```

## 3. 死锁

**什么是死锁**

线程死锁：多个线程同时被阻塞，它们中的一个或全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，它们同时想申请对方的资源、不愿意释放自己的资源并且无法被剥夺已持有资源，所以这两个线程就会互相等待而进入死锁状态。

![](https://raw.githubusercontent.com/StartZhao/blog-images/refs/heads/main/%E7%AC%94%E8%AF%95/2024-10-12_15-38-00.png)

模拟死锁情况

```java
public class DeadLockDemo {
    // 资源1
    private static Object resource1 = new Object();
    // 资源2
    private static Object resource2 = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
           synchronized (resource1) {
               System.out.println(Thread.currentThread().getName() + " get resource1");
               try {
                   Thread.sleep(1000);
               } catch (InterruptedException e) {
                   throw new RuntimeException(e);
               }
               System.out.println(Thread.currentThread().getName() + " waiting get resource2");
               synchronized (resource2) {
                   System.out.println(Thread.currentThread().getName() + " get resource2");
               }
           }
        },"线程 A").start();
        new Thread(()->{
            synchronized (resource2) {
                System.out.println(Thread.currentThread().getName() + " get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(Thread.currentThread().getName() + " waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread().getName() + " get resource1");
                }
            }
        }, "线程 B").start();
    }
}
```

线程 A 通过 `synchronized (resource1)` 获得 `resource1` 的对象锁，让线程 A 休眠 1s 保证 线程 B 能通过 `synchronized (resource2)` 获得 `resource2` 的对象锁。线程 A 和 线程 B 结束休眠都想请求获取对方的资源，从而这两个线程陷入互相等待的状态，这也就是产生了死锁。

死锁产生的**四个必要条件**

+ 互斥条件：该资源在任意时刻只能由一个线程持有。
+ 请求与保持条件：一个线程请求资源而阻塞时，对已持有的资源保持不放。
+ 不剥夺条件：线程已持有资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后主动释放资源。
+ 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

**如何预防死锁**
预防死锁只要破坏死锁形成的四个必要条件即可

* 互斥条件：如果资源不互斥，会导致线程不安全，所以这个条件不能破坏。
* 请求与保持条件：一次性申请所有资源。
* 不剥夺条件：持有部分资源的线程进一步申请资源，如果申请不到资源，主动释放它持有的资源。
* 循环等待条件：按序申请资源来破坏。按某一顺序申请资源，反序释放资源。

**如何避免死锁**

避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

> **安全状态**：系统能够按照某种线程推进顺序（$P_1$、$P_2$、$P_3.$....$P_n$）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使得每个线程都可顺利完成。称 <$P_1$、$P_2$、$P_3.$....$P_n$> 序列为安全序列。

只要修改线程 B 对资源获取的顺序即可破坏死锁

```java
        new Thread(()->{
            synchronized (resource1) {
                System.out.println(Thread.currentThread().getName() + " get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(Thread.currentThread().getName() + " waiting get resource2");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread().getName() + " get resource2");
                }
            }
        }, "线程 B").start();
```

线程 A 首先获取 `resource1` 的对象锁，线程 B 获取不到资源则陷入阻塞状态。然后线程 A 结束休眠，获取 `resource2` 的对象锁，然后线程 A 执行完毕，释放了资源。线程 B 就能获取到所需所有资源，从而执行完毕。因此避免了死锁。