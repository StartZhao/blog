---
tag:
 - 面试
---

# 面试（2024年10月11日-至今）

## 同样线程安全，为什么使用ConcurrentHashMap不用HashTable

### 1. 性能

- **分段锁机制**：`ConcurrentHashMap` 使用分段锁（Segment Locking），将整个哈希表分成多个段，每个段可以独立锁定。这意味着多个线程可以同时访问不同的段，从而提高并发性能。
- **锁粒度更细**：相比之下，`Hashtable` 对整个表施加一个单一的锁，导致在高并发情况下性能下降，因为只有一个线程可以访问表中的元素。

### 2. 更好的并发性

- **读操作更快**：在 `ConcurrentHashMap` 中，读操作不需要加锁，允许多个线程并发读取，进一步提升性能。这对于读取频繁、写入较少的场景尤为重要。
- **只在必要时加锁**：`ConcurrentHashMap` 只在需要更新某个特定部分时才会加锁，而不是对整个结构加锁，这样可以减少竞争和等待时间。

### 3. 现代化的API

- **支持Java 8的新特性**：`ConcurrentHashMap` 提供了一些现代的 API，例如 `forEach()`, `compute()`, 和 `merge()` 等方法，这些方法利用了 Lambda 表达式，使得操作更加简洁和高效。
- **更好的迭代行为**：`ConcurrentHashMap` 的迭代器是弱一致性的，不会抛出 `ConcurrentModificationException`，即使在遍历期间有其他线程对表进行了修改。

### 4. 避免全局锁的开销

- **高并发情况下的可扩展性**：由于 `Hashtable` 使用全局锁，因此在高并发情况下可能会导致大量线程争用锁，影响性能。而 `ConcurrentHashMap` 的设计更适合高并发环境，能有效避免锁竞争带来的性能瓶颈。

### 5. 不允许 Null 值

- **设计哲学**：`ConcurrentHashMap` 不允许使用 `null` 作为键或值，这使得其在多线程环境中更容易避免一些潜在的错误。在 `Hashtable` 中，键和值都可以是 `null`，这可能会导致意外的空指针异常。