---
tag:
 - 数据库
 - MySQL
---

# MySQL索引

## 一、MySQL 索引是什么

**索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。同理 MySQL 索引也是如此。**

## 二、使用 MySQL 索引的必要性

使用索引**优点**：

+ 使用索引可以大大加快数据的检索速度，这对数据量不大的情况可能不那么明显，但是在数据量非常大的情况提高速度非常明显。
+ 可创建唯一索引保证数据库记录的唯一性。

由于我们使用数据库必定存在大量查询操作，所以使用索引是有其必要性。索引优点如此显著，也必然会带来相应的代价。

**代价**：

+ 创建索引和维护索引需要耗费许多时间。当对数据进行增删改操作，如果存在索引，那么索引也需要动态修改，会降低执行效率。
+ 索引需要使用物理文件存储，会耗费一定空间。

综上，我们合理规划索引，合理分析数据库规模是否需要索引。如果需要索引，阿里规范建议一张表的索引不要超过五个。

索引底层使用什么数据结构取决于使用的数据库引擎。对于 MySQL 的 InnoDB 引擎和 MyISAM 引擎都是采用 B+ 树的形式实现索引。

## 三、MySQL索引有哪些索引

按照底层存储方式划分：

+ 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB中的主键索引就属于聚簇索引。
+ 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引。MySQL的MyISAM引擎，不管主键还是非主键，使用的都是非聚簇索引。

按照应用维度划分：

+ 主键索引：加速查询+列值唯一（不可以有NULL）+表中只有一个。
+ 普通索引：仅加速查询。
+ 唯一索引：加速查询+列值唯一（可以有NULL）。
+ 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
+ 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
+ 全文索引：对文本的内容进行分词，进行搜索。目前只有`CHAR`、`VARCHAR`、`TEXT`列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如Elastic Search代替。

**MySQL 8.x 中实现的索引新特性**

- 隐藏索引：也称为不可见索引，不会被优化器使用，但仍然需要维护。通常用于软删除和灰度发布的场景中，评估移除某个索引的影响。主键不能设置为隐藏（包括显式设置或隐式设置）。
- 降序索引：之前的版本虽然支持通过 `DESC` 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引，这有助于优化涉及降序排序的查询。
- 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，即在索引中可以包含函数或者表达式。这使得优化复杂查询成为可能。
- GROUP BY 隐式排序：在 MySQL 8.x 版本中，`GROUP BY` 语句不再进行隐式排序。如果需要对结果进行排序，必须显式添加 `ORDER BY` 子句。

## 四、什么是索引下推

**索引下推**（Index Condition Pushdown，简称 ICP）是 MySQL 5.6 版本中提供的一项索引优化功能。它允许存储引擎在索引遍历过程中，执行部分 `WHERE` 子句的判断条件，直接过滤掉不满足条件的记录。通过这种方式，ICP 可以减少回表次数，从而显著提高查询效率。

**工作原理**：

在没有 ICP 的情况下，MySQL 需要先通过索引找到符合条件的记录，然后回表获取完整的行数据，再进行 `WHERE` 条件的最终过滤。这会导致不必要的回表操作，增加 I/O 开销。

启用 ICP 后，存储引擎可以在索引层就对 `WHERE` 条件进行初步过滤，只将真正符合条件的记录返回给服务器层。这样可以大幅减少回表的次数，尤其是在索引覆盖不完全的情况下，效果尤为明显。

**适用场景**：

- **复合索引**：当查询条件涉及多个列时，ICP 可以在索引层对这些条件进行初步过滤。
- **非覆盖索引**：即使索引不能完全覆盖查询所需的所有列，ICP 仍然可以通过索引层的初步过滤减少回表次数。
- **范围查询**：对于包含范围条件的查询，ICP 可以有效减少不必要的回表操作。

**检查 ICP 是否启用**：

你可以通过以下方式检查 ICP 是否启用：

```SQL
SHOW VARIABLES LIKE 'optimizer_switch';
```

查找输出中的 `index_condition_pushdown` 选项，如果其值为 `on`，则表示 ICP 已启用。如果需要手动启用或禁用 ICP，可以通过以下命令进行设置：

```SQL
SET optimizer_switch = 'index_condition_pushdown=on';
-- 或者
SET optimizer_switch = 'index_condition_pushdown=off';
```

## 五、正确使用索引的建议

### （一）选择合适字段创建索引

- **不为 NULL 的字段**：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段**：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段**：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段**：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段**：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。
- **被频繁更新的字段不要创建索引**：虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

### （二）限制每张表上的索引数量

阿里规范建议一张表的索引不要超过五个。

### （三）尽可能考虑联合索引而不是单列索引

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

### （四）避免冗余索引

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

### （五）字符串类型使用前缀索引代替普通索引

前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。

### （六）避免索引失效

索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：

- `SELECT *` 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;
- 创建了联合索引，但查询条件未遵守最左前缀匹配原则;
- 在索引列上进行计算、函数、类型转换等操作;
- 查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;
- IN 的取值范围较大时会导致索引失效，走全表扫描(NOT IN 和 IN 的失效场景相同);
- 发生隐式转换;
- ……

### （七）删除长期未使用的索引

删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。

MySQL 5.7 可以通过查询 `sys` 库的 `schema_unused_indexes` 视图来查询哪些索引从未被使用。

### （八）分析SQL语句是否走索引

使用 `EXPLAIN` 命令来分析 SQL 的 **执行计划** ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。

`EXPLAIN`各个字段的含义:

| 字段            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| `id`            | 查询的标识符。如果查询包含子查询或联合查询，每个部分都有一个唯一的 `id`。 |
| `select_type`   | 查询的类型。<br>- `SIMPLE`：简单的查询，没有子查询或联合查询。<br>- `PRIMARY`：最外层的查询。<br>- `SUBQUERY`：子查询中的第一个 `SELECT`。<br>- `DERIVED`：派生表（来自 `FROM` 子句中的子查询）。<br>- `UNION`：联合查询的第二个或后续 `SELECT`。 |
| `table`         | 涉及的表名。如果表是派生表或子查询，可能会显示别名。         |
| `partitions`    | 涉及的分区（如果表是分区表）。                               |
| `type`          | 访问类型，表示如何访问表中的行。<br>- `ALL`：全表扫描。<br>- `index`：全索引扫描。<br>- `range`：索引范围扫描。<br>- `ref`：非唯一索引扫描。<br>- `eq_ref`：唯一索引扫描。<br>- `const`：常量扫描。<br>- `system`：系统表扫描。 |
| `possible_keys` | 可能使用的索引。                                             |
| `key`           | 实际使用的索引。                                             |
| `key_len`       | 使用的索引长度（字节数）。                                   |
| `ref`           | 引用的列或常量。                                             |
| `rows`          | 估计需要检查的行数。                                         |
| `filtered`      | 估计的过滤百分比（表示在索引或表扫描后，通过过滤条件保留的行的百分比）。 |
| `Extra`         | 额外的信息。<br>- `Using where`：使用了 `WHERE` 子句。<br>- `Using index`：覆盖索引，查询的所有列都在索引中。<br>- `Using temporary`：使用了临时表。<br>- `Using filesort`：使用了文件排序。<br>- `Using join buffer`：使用了连接缓冲区。<br>- `Impossible WHERE`：`WHERE` 子句总是为假。<br>- `Distinct`：使用了 `DISTINCT` 关键字。<br>- `Not exists`：使用了 `LEFT JOIN` 或 `RIGHT JOIN` 时，`ON` 条件为假。 |

