---
tag:
  - 系统设计
  - 高可用
---

# 如何保证接口幂等

## 一、接口幂等是什么

在系统设计中，接口幂等是指一个操作或请求无论被执行多少次，其产生的效果与只执行一次相同。

在进行数据操作中，查找是天生幂等的，在大多数情况下，删除也是幂等的，除了ABA场景。但是在保持接口幂等时可以不考虑删除，因为删除本身目的就是删除该条记录，而不在意期间是否插入相同记录。同时，ABA出现可能性极低，以及解决ABA问题通常需要额外机制，该行为会增加系统的复杂度和额外开销。在幂等上，更新与删除操作类似。但是要额外注意下类似`update table set a = a + 1 where v = 1`操作，会导致不幂等。大多数情况下，插入都是不幂等的。

接口幂等问题通常是由于网络波动、用户重复操作、超时重试、消息重复消费、响应速度慢等原因导致的。

## 二、为什么要保证接口幂等

+ 避免数据不一致
+ 提高系统健壮性：减少由于重复请求导致的错误
+ 增强用户体验：如不会让用户出现已经付钱了，但还要用户付钱的情况
+ 减少资源浪费：如避免重复的数据库写入操作

## 三、如何保证接口幂等

保证接口幂等方法核心都是添加唯一性凭证。

### （一）悲观锁

JDK提供的`ReentrantLock`类、`synchronized`关键字可实现。但是JDK提供的锁都是本地锁，无法在分布式环境下使用。

数据库本身有排他锁（X 锁，也称写锁/独占锁）。排他锁只能在支持事务的存储引擎（如 InnoDB）中使用，且只能在事务中使用。排他锁只能在有索引的字段上使用，否则会锁住整个表，影响并发性能。

高并发的场景下，会出现激烈的锁竞争关系造成线程阻塞，大量阻塞线程频繁切换上下文，增加系统开销。并且，悲观锁还存在死锁问题，影响代码正常运行。

### （二）乐观锁

乐观锁一般会使用版本号机制或CAS算法实现。

高并发的场景下，如果冲突频繁（写占比非常多的情况下）发生，会频繁失败和重试（悲观锁的开销是固定的），这样同样非常影响性能，导致CPU飙升。

乐观锁只适用于更新操作的幂等。

### （三）唯一索引

通过在表中加唯一索引，保证数据的唯一性。

唯一索引只适用于插入操作的幂等。

### （四）去重表

去重表本质也是一种唯一索引方案。去重表是一张专门记录请求信息的表，其中某个字段需要建立唯一索引，用于表示请求的唯一性。

### （五）分布式锁

分布式系统不同的服务/客户端通常运行在独立的JVM进程上，需要使用分布式锁。

分布锁通常使用Redis或Zookeeper实现，MySQL也可以实现但不推荐。

### （六）token机制

Token机制的核心思想是为每一次操作生成一个唯一性的凭证 token。这个 token 需要由服务端生成，因为服务端可以对token进行签名和加密，防止篡改和泄露。如果由客户端生成token，可能会存在安全隐患，比如客户端伪造或重复token，导致服务端无法识别和校验。

### （七）redis的set机制

将特定前缀+前端请求的url+前端请求内容+token作为redis的键，设置一定的过期时间，若在这期间，能匹配上该键，则证明是重复提交。

### （八）前端按钮加限制

为用户连续点击按钮设置等待时间。影响用户的体验。

### （九）前端本地缓存

在前端请求拦截器中，设置缓存，缓存请求的url+请求内容+请求时间。每次请求，比较该请求url与缓存的请求url是否相同，请求内容与缓存的请求内容是否相同，比较请求的当前时间与缓存的请求时间是否在不可允许的范围内，若以上都为真，则认为该次请求为重复请求。